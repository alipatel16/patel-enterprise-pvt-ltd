import { useState, useEffect, useCallback, useRef } from 'react';
import notificationService from '../services/api/notificationService';
import { useAuth } from './useAuth';
import { useUserType } from './useUserType';

export const useNotifications = () => {
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [autoGenerating, setAutoGenerating] = useState(false);
  
  const { user } = useAuth();
  const { userType } = useUserType();
  
  // Use refs to prevent unnecessary re-renders
  const hasAutoGenerated = useRef(false);
  const isInitialLoad = useRef(true);
  const lastLoadTime = useRef(0);

  // Force refresh - UPDATED: Use enhanced generator
  const refreshNotifications = useCallback(async () => {
    console.log('ðŸ”„ Force refreshing notifications with enhanced system...');
    
    if (!user || !userType) return;
    
    try {
      setLoading(true);
      
      // STEP 1: First clear all existing EMI/delivery notifications
      const { default: enhancedEMIGenerator } = await import('../services/cleanEMINotificationGenerator');
      console.log('ðŸ§¹ Clearing old notifications...');
      const deletedCount = await enhancedEMIGenerator.clearAllNotifications(userType, user.uid);
      console.log(`âœ… Cleared ${deletedCount} old notifications`);
      
      // STEP 2: Generate fresh notifications with enhanced tracking
      console.log('ðŸš€ Generating fresh notifications with due date change tracking...');
      const result = await enhancedEMIGenerator.generateAllNotifications(userType, user.uid);
      console.log('âœ… Fresh generation result:', result);
      
      // STEP 3: Reset flags and reload
      hasAutoGenerated.current = true; // Mark as generated
      isInitialLoad.current = false;
      
      // STEP 4: Load fresh data
      await loadNotifications(false, true); // false = no loading, true = skip auto-generation
      
      console.log('ðŸŽ‰ Notification refresh completed successfully');
      
    } catch (err) {
      console.error('âŒ Error refreshing notifications:', err);
      setError('Failed to refresh notifications');
    } finally {
      setLoading(false);
    }
  }, [user, userType]);

  // CRITICAL FIX: Expose refresh function globally for due date changes
  useEffect(() => {
    if (refreshNotifications) {
      window.refreshNotifications = refreshNotifications;
      console.log('ðŸŒ Exposed refreshNotifications globally');
    }
    
    return () => {
      if (window.refreshNotifications) {
        delete window.refreshNotifications;
      }
    };
  }, [refreshNotifications]);

  // CRITICAL FIX: Listen for due date change events
  useEffect(() => {
    const handleEMINotificationUpdate = async (event) => {
      console.log('ðŸ“¨ Received EMI notification update event:', event.detail);
      
      if (event.detail?.type === 'due-date-change') {
        console.log('ðŸ“… Due date change detected - refreshing notifications...');
        
        // Small delay to ensure database updates are complete
        setTimeout(async () => {
          try {
            await refreshNotifications();
            console.log('âœ… Notifications refreshed after due date change');
          } catch (error) {
            console.error('âŒ Failed to refresh notifications after due date change:', error);
          }
        }, 1000); // 1 second delay
      }
    };

    // Listen for custom EMI notification update events
    window.addEventListener('emi-notification-update', handleEMINotificationUpdate);
    
    return () => {
      window.removeEventListener('emi-notification-update', handleEMINotificationUpdate);
    };
  }, [refreshNotifications]);

  // Auto-generate notifications (UPDATED: Use enhanced generator)
  const autoGenerateNotifications = useCallback(async (force = false) => {
    // Prevent multiple simultaneous generations
    if (autoGenerating || (!force && hasAutoGenerated.current)) {
      return false;
    }

    if (!user || !userType) {
      return false;
    }

    // Debounce - don't generate more than once every 30 seconds
    const now = Date.now();
    if (!force && (now - lastLoadTime.current) < 30000) {
      return false;
    }

    try {
      setAutoGenerating(true);
      console.log('ðŸ¤– Auto-generating notifications with enhanced system...');

      // UPDATED: Import enhanced generator instead of clean one
      const { default: enhancedEMIGenerator } = await import('../services/enhancedEMINotificationGenerator');
      
      // Generate all notifications (EMI + Delivery + cleanup) with due date change tracking
      const result = await enhancedEMIGenerator.generateAllNotifications(userType, user.uid);
      
      console.log('âœ… Enhanced auto-generation completed:', result);
      
      // Mark that we've auto-generated for this session
      hasAutoGenerated.current = true;
      lastLoadTime.current = now;
      
      // Return true if notifications were generated/cleaned up
      return result.total > 0 || result.cleanup?.delivered > 0;
      
    } catch (err) {
      console.warn('âš ï¸ Auto-generation failed (non-critical):', err);
      return false;
    } finally {
      setAutoGenerating(false);
    }
  }, [user, userType, autoGenerating]);

  // Load notifications with optimized logic
  const loadNotifications = useCallback(async (showLoading = true, skipAutoGeneration = false) => {
    if (!user || !userType) {
      // Clear state when no user/userType
      setNotifications([]);
      setUnreadCount(0);
      setError(null);
      return;
    }

    try {
      if (showLoading) setLoading(true);
      setError(null);
      
      // Step 1: Auto-generate notifications ONLY on initial load or when explicitly requested
      let shouldReload = false;
      if (!skipAutoGeneration && isInitialLoad.current) {
        shouldReload = await autoGenerateNotifications();
        isInitialLoad.current = false; // Mark that initial load is complete
      }
      
      // Step 2: Fetch all notifications from database
      console.log('ðŸ“¥ Fetching notifications from database...');
      const data = await notificationService.getNotifications(userType, user.uid);
      
      console.log(`ðŸ“Š Fetched ${data.length} notifications from database`);
      
      // Step 3: Sort by createdAt descending to ensure newest first
      const sortedData = data.sort((a, b) => {
        const dateA = new Date(a.createdAt);
        const dateB = new Date(b.createdAt);
        return dateB - dateA;
      });
      
      // Step 4: Set new data
      setNotifications(sortedData);
      setUnreadCount(sortedData.filter(n => !n.read).length);
      
    } catch (err) {
      setError('Failed to load notifications');
      console.error('âŒ Error loading notifications:', err);
      
      // Clear state on error
      setNotifications([]);
      setUnreadCount(0);
    } finally {
      if (showLoading) setLoading(false);
    }
  }, [user, userType, autoGenerateNotifications]);

  // Mark notification as read
  const markAsRead = useCallback(async (notificationId) => {
    if (!userType) return;
    
    try {
      await notificationService.markAsRead(userType, notificationId);
      
      setNotifications(prev => 
        prev.map(n => 
          n.id === notificationId ? { ...n, read: true, readAt: new Date().toISOString() } : n
        )
      );
      
      setUnreadCount(prev => Math.max(0, prev - 1));
    } catch (err) {
      console.error('âŒ Error marking notification as read:', err);
      setError('Failed to mark notification as read');
    }
  }, [userType]);

  // Mark all notifications as read
  const markAllAsRead = useCallback(async () => {
    if (!userType || !user) return;
    
    try {
      await notificationService.markAllAsRead(userType, user.uid);
      
      setNotifications(prev => 
        prev.map(n => ({ ...n, read: true, readAt: new Date().toISOString() }))
      );
      setUnreadCount(0);
    } catch (err) {
      console.error('âŒ Error marking all notifications as read:', err);
      setError('Failed to mark all notifications as read');
    }
  }, [userType, user]);

  // Delete notification
  const deleteNotification = useCallback(async (notificationId) => {
    if (!userType) return;
    
    try {
      await notificationService.deleteNotification(userType, notificationId);
      
      setNotifications(prev => {
        const notification = prev.find(n => n.id === notificationId);
        const newNotifications = prev.filter(n => n.id !== notificationId);
        
        // Update unread count if deleted notification was unread
        if (notification && !notification.read) {
          setUnreadCount(prevCount => Math.max(0, prevCount - 1));
        }
        
        return newNotifications;
      });
    } catch (err) {
      console.error('âŒ Error deleting notification:', err);
      setError('Failed to delete notification');
    }
  }, [userType]);

  // Create notification
  const createNotification = useCallback(async (notificationData) => {
    if (!userType || !user) return null;
    
    try {
      const newNotification = await notificationService.createNotification(userType, {
        ...notificationData,
        userId: user.uid,
        createdAt: new Date().toISOString(),
        read: false
      });
      
      setNotifications(prev => [newNotification, ...prev]);
      setUnreadCount(prev => prev + 1);
      
      return newNotification;
    } catch (err) {
      console.error('âŒ Error creating notification:', err);
      setError('Failed to create notification');
      throw err;
    }
  }, [userType, user]);

  // Get notifications by type
  const getNotificationsByType = useCallback((type) => {
    return notifications.filter(n => n.type === type);
  }, [notifications]);

  // Get unread notifications
  const getUnreadNotifications = useCallback(() => {
    return notifications.filter(n => !n.read);
  }, [notifications]);

  // Get notifications by category
  const getNotificationsByCategory = useCallback((category) => {
    return notifications.filter(n => n.category === category);
  }, [notifications]);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Load notifications ONLY ONCE on mount and when user/userType changes
  useEffect(() => {
    // Reset flags when user/userType changes
    hasAutoGenerated.current = false;
    isInitialLoad.current = true;
    
    loadNotifications();
  }, [user?.uid, userType]); // Only depend on user ID and userType, not the entire user object

  // Auto-refresh every 10 minutes (background only, no auto-generation)
  useEffect(() => {
    if (!user || !userType) return;

    const interval = setInterval(() => {
      console.log('ðŸ”„ Background refresh (no auto-generation)...');
      loadNotifications(false, true); // false = silent, true = skip auto-generation
    }, 600000); // 10 minutes

    return () => clearInterval(interval);
  }, [user?.uid, userType, loadNotifications]);

  return {
    // Data
    notifications,
    unreadCount,
    loading,
    error,
    autoGenerating,
    
    // Actions
    loadNotifications,
    refreshNotifications,
    markAsRead,
    markAllAsRead,
    deleteNotification,
    createNotification,
    clearError,
    
    // Utilities (exposed but controlled)
    autoGenerateNotifications,
    
    // Computed values
    hasUnread: unreadCount > 0,
    hasNotifications: notifications.length > 0,
    
    // Filtered getters
    getNotificationsByType,
    getUnreadNotifications,
    getNotificationsByCategory,
    
    // Counts by type
    getUnreadCountByType: useCallback((type) => {
      return notifications.filter(n => !n.read && n.type === type).length;
    }, [notifications]),
    
    getCountByCategory: useCallback((category) => {
      return notifications.filter(n => n.category === category).length;
    }, [notifications])
  };
};